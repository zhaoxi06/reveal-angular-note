依赖注入的作用在于管理组件与服务之间的依赖关系，有利于各种组件之间解耦，代码易于维护，提升开发效率。

## 依赖注入与传统依赖管理
### 传统的依赖管理
* 调用者负责管理所有对象的依赖。
* 缺点：容易出现循环依赖
### 依赖注入
* 由注入器管理所有对象的依赖，它在运行时（而不是发生在编译时）负责替换依赖对象，这称为控制反转(IoC)。

## Angular依赖注入
### 三个重要概念
* 注入器(Injector)：就像制造工厂，提供了一系列的接口用于创建依赖对象的实例
* Provider：用于配置注入器，注入器通过它来创建被依赖对象的实例，Provider把标识（Token）映射到工厂方法，被依赖的对象就是通过该方法来创建的。
* 依赖：指定了被依赖对象的类型，注入器会根据此类型创建对应的对象。
在依赖注入中，注入器是粘合剂，它连接了调用方和被依赖方。注入器根据Provider的配置来生成依赖对象，调用方根据Provider提供的标识告诉注入器来获取被依赖的对象。
![依赖注入组成]('./img/dependency-injection.jpg')
我理解的意思是：使用Provider时，就创建了一个注入器；注入器创建了一个依赖对象的实例；依赖，相当于一个【名字】，即注入器创建了一个这个【名字】（它是对象）的实例。所以Provider需要提供标识和依赖，依赖用于给注入器创建实例，标识用于连接起调用方和依赖的实例。

### 在组件中注入服务
* 通过import导入被依赖对象
* 在组件中配置注入器。在启动组件时，Angular会读取@Component装饰器的providers元数据，它是一个数组，配置了该组件需要使用到的所有依赖，Angular的依赖注入框架会根据这个列表去创建对应对象的实例。
* 在组件构造函数中声明需要注入的依赖。注入器会根据构造函数上的声明，在组件初始化时通过第二步中的providers元数据配置依赖，为构造函数提供对应的依赖服务，最终完成注入的过程。
我理解的意思是：provider创建了一个注入器，注入器创建了import导入的依赖对象的实例，到这一步，仅仅是完成了创建，如果要在组件中使用这个依赖对象的实例，还得在构造函数中声明，以获取到这个依赖对象的实例。
在组件中配置了providers元数据，这使得该组件及其子组件，都能共享由该组件注入器创建的实例。需要注意的是，每个组件都可以有自己的注入器，通过依赖注入到该组件的每个服务都维持单例。如果某个组件不希望复用从该组件注入器获取的服务，可以在自己的注入器中以新的配置重新注入，这是Angular依赖注入的另一个特性，即层级注入。

### 在服务中使用服务
* 添加@Injectable()装饰器
* 在构造函数中声明所依赖的服务

### 在模块中注入服务
Angular在启动程序时会启动一个根模块，并加载它所依赖的其他模块，此时会生成一个全局的根注入器，由该注入器创建的依赖注入对象在整个应用程序级别可见，并共享一个实例。同时，根模块会指定一个根组件并启动，由该组件添加的依赖注入对象是组件树级别可见，在根组件以及子组件中共享一个实例。
Angular中没有模块级作用域这个概念，只有**应用程序级作用域**和**组件级作用域**，这种设计主要考虑模块的扩展性，一个应用程序通常由多个模块合并而成，在@NgModule里注册的服务默认在整个应用程序内可用。
延迟加载的模块是个例外。模块的延迟加载使得应用程序在启动时不被载入，而是结合路由配置，在需要时才动态加载相应模块。Angular会对延迟加载模块初始化一个新的执行上下文，并创建一个新的注入器，在该注入器的依赖只在该模块内部可见。
如果多个模块中都注入了相同标识的服务，因为根注入器只有一个，后面初始化的模块服务会覆盖前面初始化的模块服务。
假如A模块导入B模块，A和B模块同时注入了C服务，A模块和B模块都注册到了根模块，应用程序里使用的C服务会是A模块中注入的服务，而不是B模块。按这种结论延伸，在根模块里注入的服务始终都是有最高优先级的，所以根模块里注入的服务可以放心使用。
在组件的构造函数试图使用某个服务的时候，Angular会先从当前组件的注入器查找，找不到就继续往父组件的注入器查找，直到根组件注入器，最后到应用根注入器（即模块注入器），此时找不到的话就报错了。

个人观点：书中介绍的是在组件中注入服务、在服务中注入服务、在模块中注入服务。我的个人理解是，注入服务(用providers注入)的方式有两种，在组件中注入和在模块中注入。服务注入后，可以在组件、服务、模块中使用(在constructor函数中声明)。

### 注入到派生组件
组件本质上是一个类，而类有继承的关系，所以一个组件可以继承另一个组件。但派生类组件不能继承父类组件的注入器，二者的注入器对象并没有任何关联，而且需要注意的一点是，因为父类组件的运行可能需要依赖注入某些服务，所以派生类组件也必须注入父类组件依赖的服务，然后调用super()将对应服务传递到父类。

### 限定方式的依赖注入
* @Optional可以兼容依赖不存在的情况，提高系统的健壮性
* @Host可以限定查找规则，明确实例初始化的位置，避免一些莫名的共享对象问题。如果一个组件注入了依赖项，那么该组件就是这个依赖项的宿主组件。但如果这个组件通过ng-content被嵌入到父组件，那这个父组件就是该依赖项的宿主组件。

## Provider
> Provider对象字面量（如{provide: Head, useClass: Head}）把一个标识映射到一个可配置的对象，这个标识可以是一个类名，也可以是个字符串。其中provide属性可以理解为这个Provider的唯一标识，用于定位依赖值以及注册Provider，也就是应用中使用的服务名，而useClass属性则代表使用哪个服务类去创建实例。
### Provider注册方式
* 类Provide：useClass
* 值Provide：useValue。值Provider依赖的值必须在当前或者providers元数据配置之前定义。
* 别名Provider：useExisting
* 工厂Provider：useFactory

## 扩展
### 在子组件获取父组件的实例
每个组件的实例都会添加到注入器的容器里，因此可通过依赖注入来找到父组件的实例。
* 已知父组件的类型
```
// child.component.ts
export class ChildComponent{
    constructor(public parent: ParentComponent){}
}
```
* 未知父组件的类型
一个组件可能是多个组件的子组件，有时候无法直接知道父组件的类型，可通过“类-接口”的方式来查找，即让父组件通过提供一个与“类-接口”标识同名的别名来协助查找。
“类-接口”其实是一个抽象类，但被当做接口来使用。因为接口是typescript里才有的概念，编译后并不存在，因此Provider的标识不能是接口，只能是JavaScript对象（函数、字符串、对象等），所以“类-接口”既能提供接口的强类型约束，又能当作Provider的标识来使用。
```
export abstract class Patent {
    name: string;
}

//parent.component.ts
@Component({
    selector: 'patent',
    template: ``,
    providers: [{provide: Parent, useExisting: ParentComponent}]
})
export class ParentComponent implements Parent {
    name = '父组件';
}

//child.component.ts
export class ChildComponent {
    name = '子组件';
    constructor(public parent: Parent){}
}
```