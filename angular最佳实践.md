## 单一职责
angular是基于Web Component思想设计的，所有的核心概念包括组件、服务、指令等都遵循单一职责原则。
### 单一文件
一个组件对应一个文件可以保证代码简单、已读，具有更好的可维护性。通常一个文件的代码量不应超过400行，如果太长，则可能是组件拆分得不够细致。
### 简单函数
定义的函数尽量功能简单、目的明确、职责单一。通常一个函数的代码量不应超过75行，目的更明确且职责更单一的函数具有更高的可复用性，也便于进行测试。

## 命名约定
良好的命名规范能起到见名知意的效果，能使维护代码的开发者在只通览代码文件结构的情况下就能大致了解整个项目，并且在需要了解细节的情况下能快速定位到相应的代码位置。
### 命名风格统一
使用统一的命名风格是指保持命名方式和命名模式一致。在angular中通常采用feature.type.ts的命名模式即**先描述特征，再描述类型**。例如`user-list.component.ts`。
### 名称格式保持一致
对于文件的名称，通常使用“.”点号来分隔特性和类型，而对于特性名称由多个英文单词组成的情况，则可以使用“-”短横线作为分隔符，例如上面的`user-list.component.ts`。
使用完整的类型名称，不要使用简写的形式。例如使用.service作为服务的类型描述，而不要使用.srv, .svc， .serv等容易让人产生困惑的名称。
### 选择器命名约定
对于组件的选择器，通常采用“烤肉串”命名形式。而对于一般指令的选择器，通常采用首字母小写的驼峰命名形式。以便与组件的选择器命名区分开。
### 测试相关文件的命名约定
测试文件包括单元测试文件和端到端测试文件。一般而言，单元测试文件的命名应该与被测试的组件或者服务的文件名称一致，并添加.spec后缀，端到端测试文件名称的后缀应为.e2e.spec。
### 命名的前后缀
在必要的时候添加前后缀以区分。如普通用户的成员列表组件命名为users.component.ts，而管理员的成员列表组件命名为admin-users.component.ts。添加前缀的好处是一方面可以避免命名冲突；另一方面可以界定组件的作用范围。
### 启动文件的命名约定
启动文件是程序的入口文件，通常都是使用main.ts作为文件结构名称的，让代码的阅读者一眼便能找到程序入口。启动文件的内容应该只包含和平台相关的启动代码，不应该包含跟应用逻辑相关的任何代码，逻辑代码应该放到组件或服务中。

## 编码约定
### 类
类名采用首字母大写的驼峰命名形式。不论是组件类名、服务类名，还是指令类名。
### 常量
在typescript中，对于在整个应用的生命周期中都不会改变的变量，则可以使用const关键字修饰为常量。常量名称采用全字母大写并用下划线分隔单词的形式，形如UPPER_SNAKE_CASE。
### 接口
接口名的定义方式与普通类的定义方式一致，即首字母大写的驼峰命名形式。
### 属性和方法
属性和方法使用小写字母开头的驼峰命名形式即可。**不要画蛇添足地给私有属性或方法添加“_”下划线前缀**。因为对于javascript而言，它没有真正的私有属性或方法，而在typescript中又有private关键字可以表示私有成员，因此并不需要下划线来特别强调。一般来说，属性定义应该放在方法定义之前，而公有成员定义应放在私有成员定义之前。
### 关于import语句
当使用import语句导入一组对象时，在括号内侧加上一个空格，便于阅读。导入对象最好按字母顺序排序。导入的第三方库和项目本身的代码用空行隔开。
### 应用结构约定
* 所有的项目代码应该存放在一个名为app的文件夹中
* 将第三方代码存放在app目录之外的独立文件夹中
* 以功能特性创建并命名文件夹
* 将一个模块内的所有共享文件放在一个名为shared的文件夹中
* 将用于全局布局的组件放在shared目录中
* 使用index.ts文件作为一系列相关模块的统一导出文件
* 将需要懒加载特性的内容放在一个独立的文件夹中
* 使用路由实现组件的懒加载，不要直接导入懒加载的目录

## angular模块约定
angular中涉及的模块主要包括跟模块、特性模块、共享特性模块及核心特性模块四类。要保证每个应用至少有一个根模块，而且为了更好地定位和识别，应当考虑将根模块命名为app.module.ts；同时每一个明显的特性都要有对应的特性模块，且将模块放在与特性同名的目录中；共享特性模块是指在shared目录中创建名为ShardModule的模块，且在该共享模块中声明那些可复用的组件、指令和管道等；区别于共享特性模块，还有一类只用一次的类，这些建议收集到核心模块中，让特性模块的结构更加简洁。清晰。创建名为CoreModule的核心模块，并存放到core目录下，并且坚持将共享给整个应用的单例服务放到CoreModule中。

## 组件相关约定
### 使用元素选择器的方式定义组件
组件由指令派生而来，因此组件选择器支持元素、属性和其他的选择过滤方式。为了避免与指令定义混淆，建议定义组件都使用元素选择器的方式。
### 将模板和样式文件分别抽离成单独文件
### 使用@Input和@Output装饰器
使用@Input和@Output装饰器代替元数据中的input和output。同时，要注意避免重命名输入输出属性。
### 模板逻辑定义在组件类中
### 逻辑服务代码定义在服务中
组件应专注与视图相关的逻辑实现，其他逻辑应由服务来完成，以保持组件的简单。
### 输出属性不要添加on前缀
### 实现接口来添加生命周期钩子

## 指令相关约定
### 使用指令增强已有元素的功能
使用指令的目的在于增强已有元素的功能，当有表现出逻辑并且不需要模板时，应该使用属性指令。
### 使用Host装饰器代替host属性

## 服务相关约定
* 同一个注入器中的服务应该是单例的，通常用来共享数据或者共享函数。
* 服务应该遵循单一职责原则
* 应该在服务被共享的组件的最顶层组件注入器中注入服务
* 使用@Injectable类装饰器代替@Inject参数装饰器
* 独立数据服务，使得组件可以专注于与视图相关的处理逻辑
